---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
author: "Nate Prince"
date: "2025-10-30"
format:
  html: default
execute:
  echo: false
  eval: true
---

# ðŸŽ² Simulation Challenge - Starter Template

## The Investment Game (Brief)

"It was a clear black night, a clear white moon,
Nate Prince was in class, trying to analyze;
Whether a proposition from professor Adam was wise;
Or a ploy that would lead to his ultimate financial demise."

Professor Adam: "You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game."

Here is how the game works:

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis

### 1) Expected Value After 1 Flip

After one flip, the expected value of the account balance is **greater than** $30,000.

**Calculation:**
- If heads (50% probability): $30,000 Ã— 1.5 = $45,000
- If tails (50% probability): $30,000 Ã— 0.6 = $18,000
- Expected value = 0.5 Ã— $45,000 + 0.5 Ã— $18,000 = $31,500

The gain in expected value is **5.0%** of the buy-in ($31,500 - $30,000 = $1,500; $1,500 / $30,000 = 0.05).

However, this simple analysis is **misleading** and does not suggest you should buy-in to the game. While the expected value is positive after one flip, this ignores the compounding nature of repeated coin flips. The asymmetric returns (50% gain vs. 40% loss) create a multiplicative process where the expected value grows linearly over time, but the actual outcomes become highly skewed. Most simulations will result in losses despite the positive expected value, making this a mathematically interesting but practically risky investment.

```{python}
#| label: q1-expected-value-py
#| echo: false

# Compute expected value after one flip
initial_balance = 30000
heads_multiplier = 1.5
tails_multiplier = 0.6

# Expected balance after one flip
expected_balance = 0.5 * (initial_balance * heads_multiplier) + 0.5 * (initial_balance * tails_multiplier)

print(f"Initial balance: ${initial_balance:,.2f}")
print(f"Heads outcome: ${initial_balance * heads_multiplier:,.2f}")
print(f"Tails outcome: ${initial_balance * tails_multiplier:,.2f}")
print(f"Expected value after one flip: ${expected_balance:,.2f}")
print(f"Gain as percentage of buy-in: {((expected_balance - initial_balance) / initial_balance) * 100:.1f}%")

```

### 2) Single Simulation Over Time (Narrative + Plot)

The single simulation below shows a typical path for this investment game. Starting with $30,000, each year the coin flip either multiplies the balance by 1.5 (heads) or 0.6 (tails). With 48 years of compounding, even though the expected value after each flip is positive (+5%), the multiplicative process creates extreme volatility. In this particular run, you can see periods of both growth and decline, with the final outcome heavily dependent on the sequence of coin flips. The mathematical property that makes this investment risky is that losses compound exponentiallyâ€”a few consecutive tails can devastate the balance even if the overall expected value remains positive.

```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance over 48 years"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Simulation parameters
initial_balance = 30000
years = 48

# Initialize arrays
balances = np.zeros(years + 1)
balances[0] = initial_balance

# Simulate coin flips and calculate balance over time
for i in range(1, years + 1):
    coin_flip = np.random.rand()
    if coin_flip < 0.5:  # Heads: increase by 50%
        balances[i] = balances[i-1] * 1.5
    else:  # Tails: decrease by 40%
        balances[i] = balances[i-1] * 0.6

# Create time series plot using matplotlib OO interface
fig, ax = plt.subplots(figsize=(10, 6))
years_array = np.arange(years + 1)

ax.plot(years_array, balances, linewidth=2, color='steelblue', label='Account Balance')
ax.axhline(y=initial_balance, color='red', linestyle='--', linewidth=1.5, alpha=0.7, label='Initial Buy-in ($30,000)')
ax.set_xlabel('Years Since Buy-in', fontsize=12)
ax.set_ylabel('Account Balance ($)', fontsize=12)
ax.set_title('Single Simulation: Account Balance Over Time', fontsize=14, fontweight='bold')
ax.grid(True, alpha=0.3)
ax.legend(fontsize=10)
ax.ticklabel_format(style='plain', axis='y')

# Format y-axis to show currency properly
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Print summary statistics for this single run
print(f"Starting balance: ${initial_balance:,.2f}")
print(f"Ending balance: ${balances[-1]:,.2f}")
print(f"Final gain/loss: ${balances[-1] - initial_balance:,.2f}")
print(f"Percentage change: {((balances[-1] / initial_balance) - 1) * 100:.1f}%")

```

### 3) 100 Simulations: Distribution of Final Balances

Running 100 simulations reveals a striking property of this investment game: the distribution of final balances is highly right-skewed with a long tail extending to extremely high values. Despite the positive expected value per flip, the mean is pulled upward by a small number of extremely lucky paths, while the median remains much lower. This demonstrates the mathematical paradox: even though you would expect to gain money on average, most individual simulations actually lose money. The probability of ending above the initial $30,000 buy-in is surprisingly low, revealing why expected value alone is insufficient for making this investment decision.

```{python}
#| label: q3-dist-100-py
#| echo: false
#| fig-cap: "Distribution of final balances across 100 simulations"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Simulation parameters
initial_balance = 30000
years = 48
n_simulations = 100

# Store final balances from all simulations
final_balances = np.zeros(n_simulations)

# Run 100 simulations
for sim in range(n_simulations):
    # Reset balance for each simulation
    balance = initial_balance
    
    # Simulate 48 years of coin flips
    for year in range(years):
        coin_flip = np.random.rand()
        if coin_flip < 0.5:  # Heads: increase by 50%
            balance = balance * 1.5
        else:  # Tails: decrease by 40%
            balance = balance * 0.6
    
    # Store final balance
    final_balances[sim] = balance

# Compute statistics
mean_final = np.mean(final_balances)
median_final = np.median(final_balances)
prob_above_30k = np.mean(final_balances > 30000)

# Create histogram visualization with better scaling to show more data
fig, ax = plt.subplots(figsize=(12, 6))

# Use more bins to show more detail, and limit range to focus on bulk of distribution
# but still show outliers
q95 = np.percentile(final_balances, 95)
x_range = (0, max(q95, 100000))  # Show up to 95th percentile or $100K, whichever is larger

# Create histogram with more bins for better detail
n, bins, patches = ax.hist(final_balances, bins=40, edgecolor='black', 
                           alpha=0.8, color='steelblue', range=x_range)

# Add vertical line at $30,000
ax.axvline(x=30000, color='red', linestyle='--', linewidth=3, 
           label='Initial Buy-in ($30,000)', alpha=0.9, zorder=10)

# Add mean and median lines
ax.axvline(x=mean_final, color='green', linestyle=':', linewidth=2, 
           label=f'Mean: ${mean_final:,.0f}', alpha=0.7)
ax.axvline(x=median_final, color='orange', linestyle=':', linewidth=2, 
           label=f'Median: ${median_final:,.0f}', alpha=0.7)

# Color bars based on whether they're above or below initial buy-in
for i, patch in enumerate(patches):
    patch.set_facecolor('crimson' if bins[i] < 30000 else 'forestgreen')

ax.set_xlabel('Final Account Balance ($)', fontsize=13, fontweight='bold')
ax.set_ylabel('Frequency (Count)', fontsize=13, fontweight='bold')
ax.set_title('Distribution of Final Balances: 100 Simulations', 
             fontsize=15, fontweight='bold', pad=15)
ax.grid(True, alpha=0.3, axis='y')
ax.legend(fontsize=11, loc='upper right')
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))

# Add text annotation showing outliers if any are cut off
if np.max(final_balances) > x_range[1]:
    ax.text(0.98, 0.95, f'Note: {np.sum(final_balances > x_range[1])} outlier(s) above ${x_range[1]/1000:.0f}K not shown', 
            transform=ax.transAxes, fontsize=9, ha='right', va='top',
            bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

plt.tight_layout()
plt.show()

# Print statistics
print(f"Mean final balance: ${mean_final:,.2f}")
print(f"Median final balance: ${median_final:,.2f}")
print(f"P(final > $30,000): {prob_above_30k:.3f}")
print(f"P(final â‰¤ $30,000): {1 - prob_above_30k:.3f}")

```

### 4) Probability Balance > $30,000 at Age 75 (Original Game)

Using the 100 simulations above, the probability that your final balance exceeds the initial $30,000 buy-in is quite low. This probability estimate reveals the practical meaning of the expected value paradox: while the arithmetic mean suggests you should invest, the majority of individual outcomes result in losses. This happens because the geometric mean of returns (which governs actual wealth growth) is negative even though the arithmetic mean is positive. For most individual investors, you would expect to lose money over the 48-year period, making this investment unsuitable despite its positive expected value.

```{python}
#| label: q4-prob-original-py
#| echo: false

# Re-run simulations to compute P(final > 30000) 
# (This ensures the cell is standalone and produces the estimate)
import numpy as np

np.random.seed(42)

initial_balance = 30000
years = 48
n_simulations = 100

final_balances = np.zeros(n_simulations)

for sim in range(n_simulations):
    balance = initial_balance
    for year in range(years):
        coin_flip = np.random.rand()
        if coin_flip < 0.5:
            balance = balance * 1.5
        else:
            balance = balance * 0.6
    final_balances[sim] = balance

prob_above_30k = np.mean(final_balances > 30000)

print(f"Estimated P(final > $30,000): {prob_above_30k:.3f}")

```

### 5) Modified Strategy (Bet Exactly 50% Each Round)

Nate Prince: " How about this... Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. I'll compare this to the original game. Which is riskier? Which has better upside?" Professor Adam: "I'll let you decide."



The modified strategy dramatically changes the risk profile. By only gambling 25% of your balance each year, you preserve 75% of your wealth regardless of the coin flip outcome. This creates a fundamentally different probability structure: heads multiplies 25% by 1.5 and adds it back, while tails multiplies 25% by 0.6. The modified strategy is less risky and has a lower probability of ruin, but also has less upside potential since only a fraction of wealth is exposed to the beneficial compound growth. The distribution of outcomes is more centered and predictable compared to the original's extreme skewness.

```{python}
#| label: q5-modified-50pct-py
#| echo: false
#| fig-cap: "Comparison of original vs modified strategy distributions"

import numpy as np
import matplotlib.pyplot as plt

np.random.seed(42)

initial_balance = 30000
years = 48
n_simulations = 100

# Store results for both strategies
original_final = np.zeros(n_simulations)
modified_final = np.zeros(n_simulations)

# Run 100 simulations for original strategy
for sim in range(n_simulations):
    balance = initial_balance
    for year in range(years):
        coin_flip = np.random.rand()
        if coin_flip < 0.5:
            balance = balance * 1.5
        else:
            balance = balance * 0.6
    original_final[sim] = balance

# Run 100 simulations for modified strategy (bet 25%)
np.random.seed(42)  # Reset seed for same coin flip sequence
for sim in range(n_simulations):
    balance = initial_balance
    for year in range(years):
        coin_flip = np.random.rand()
        if coin_flip < 0.5:  # Heads: 25% of balance gets 50% return
            balance = balance * 0.75 + balance * 0.25 * 1.5
        else:  # Tails: 25% of balance loses 40%
            balance = balance * 0.75 + balance * 0.25 * 0.6
    modified_final[sim] = balance

# Compute statistics
original_prob = np.mean(original_final > 30000)
modified_prob = np.mean(modified_final > 30000)
original_mean = np.mean(original_final)
modified_mean = np.mean(modified_final)
original_median = np.median(original_final)
modified_median = np.median(modified_final)

# Create comparison plot
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

# Original strategy histogram
n1, bins1, patches1 = ax1.hist(original_final, bins=30, edgecolor='black', alpha=0.7, color='steelblue', range=(0, 500000))
ax1.axvline(x=30000, color='red', linestyle='--', linewidth=2, label='Initial Buy-in')
ax1.axvline(x=original_mean, color='green', linestyle='--', linewidth=1.5, alpha=0.7)
ax1.set_xlabel('Final Balance ($)', fontsize=13, fontweight='bold')
ax1.set_ylabel('Frequency', fontsize=13, fontweight='bold')
ax1.set_title(f'Original Strategy\nMean: ${original_mean:,.0f}, P(>30k): {original_prob:.3f}', fontsize=14, fontweight='bold')
ax1.legend(fontsize=11)
ax1.grid(True, alpha=0.3, axis='y')
ax1.set_yscale('log')
ax1.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))
ax1.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'{int(x)}'))

# Color bars based on whether they're above or below initial buy-in
for i, patch in enumerate(patches1):
    patch.set_facecolor('crimson' if bins1[i] < 30000 else 'forestgreen')

# Modified strategy histogram
n2, bins2, patches2 = ax2.hist(modified_final, bins=30, edgecolor='black', alpha=0.7, color='coral', range=(0, 500000))
ax2.axvline(x=30000, color='red', linestyle='--', linewidth=2, label='Initial Buy-in')
ax2.axvline(x=modified_mean, color='green', linestyle='--', linewidth=1.5, alpha=0.7)
ax2.set_xlabel('Final Balance ($)', fontsize=13, fontweight='bold')
ax2.set_ylabel('Frequency', fontsize=13, fontweight='bold')
ax2.set_title(f'Modified Strategy (25% bet)\nMean: ${modified_mean:,.0f}, P(>30k): {modified_prob:.3f}', fontsize=14, fontweight='bold')
ax2.legend(fontsize=11)
ax2.grid(True, alpha=0.3, axis='y')
ax2.set_yscale('log')
ax2.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))
ax2.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'{int(x)}'))

# Color bars based on whether they're above or below initial buy-in
for i, patch in enumerate(patches2):
    patch.set_facecolor('crimson' if bins2[i] < 30000 else 'forestgreen')

plt.tight_layout()
plt.show()

# Print comparison
print("=" * 60)
print("COMPARISON: Original vs Modified Strategy")
print("=" * 60)
print(f"\nOriginal Strategy:")
print(f"  Mean: ${original_mean:,.2f}")
print(f"  Median: ${original_median:,.2f}")
print(f"  P(final > $30,000): {original_prob:.3f}")
print(f"\nModified Strategy (25% bet):")
print(f"  Mean: ${modified_mean:,.2f}")
print(f"  Median: ${modified_median:,.2f}")
print(f"  P(final > $30,000): {modified_prob:.3f}")
print("\nWhich is riskier? The ORIGINAL strategy (higher variance, more extreme outcomes)")
print("Which has better upside? The ORIGINAL strategy (higher mean, more high-value outliers)")
print("Which is safer? The MODIFIED strategy (higher P(>30k), less variance)")

```

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
 
Nate Prince: "I've heard of the Kelly Criterion, but I'm not sure how it applies to this game."
Professor Adam: "Let's take a look."

The Kelly Criterion is a mathematical formula that determines the optimal fraction of capital to bet on repeated favorable bets to maximize long-term growth rate. It balances the desire to maximize expected returns against the risk of ruin. The formula is: f* = (bp - q) / b, where f* is the fraction to bet, b is the net odds received, p is the probability of winning, and q is the probability of losing (q = 1 - p).

For the coin flip game, let's analyze: p = 0.5 (probability of heads), b = 0.5 (net gain of 50%), and q = 0.4 (net loss of 40%). This gives: f* = (0.5 Ã— 0.5 - 0.4) / 0.5 = (0.25 - 0.4) / 0.5 = -0.3. Since the result is negative, the Kelly Criterion recommends not betting at allâ€”the bet is unfavorable despite having a positive expected value.

This explains the paradox: the game has positive expected value but is a losing proposition in the long run. The modified strategy of betting only 25% acknowledges this reality by reducing the bet fraction, which improves the probability of ending above the initial investment. However, even 25% is above the Kelly-optimal fraction (0%), which explains why the original strategy results in most outcomes being below the initial investment despite the positive expected value.


# Conclusion 

The investment game is a classic example of the importance of considering the long-term implications of short-term gains. While the expected value suggests that investing in this game is a good idea, the reality is that most individual outcomes result in losses. This is because the multiplicative nature of the game creates a high variance in outcomes, with a small number of extremely lucky paths pulling the mean upward. The modified strategy of betting only 25% of the balance each year is a more realistic approach that reduces the risk of ruin while still maintaining a positive expected value.

In short, professor Adam's proposition is a losing proposition in the long run. Tried to set us up for financial failure ðŸ¤¦ And Nate Prince is still trying to figure out how to get his money back.

