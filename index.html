<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Nate Prince">
<meta name="dcterms.date" content="2025-10-30">

<title>Simulation Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Simulation Challenge</h1>
<p class="subtitle lead">Starter Template with To-Dos</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Nate Prince </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 30, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="simulation-challenge---starter-template" class="level1">
<h1>üé≤ Simulation Challenge - Starter Template</h1>
<section id="the-investment-game-brief" class="level2">
<h2 class="anchored" data-anchor-id="the-investment-game-brief">The Investment Game (Brief)</h2>
<p>‚ÄúIt was a clear black night, a clear white moon, Nate Prince was in class, trying to analyze; Whether a proposition from professor Adam was wise; Or a ploy that would lead to his ultimate financial demise.‚Äù</p>
<p>Professor Adam: ‚ÄúYou have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.‚Äù</p>
<p>Here is how the game works:</p>
<p>Each year after buy-in you flip a fair coin:</p>
<ul>
<li>Heads: increase your account balance by 50%</li>
<li>Tails: decrease your account balance by 40%</li>
</ul>
<p>You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.</p>
<section id="generative-dag-model-from-the-source-challenge" class="level3">
<h3 class="anchored" data-anchor-id="generative-dag-model-from-the-source-challenge">Generative DAG Model (from the source challenge)</h3>
<p>The following DAFT diagram shows the generative structure of the investment game over time.</p>
<div id="cell-fig-investment-dag" class="cell" data-execution_count="2">
<div class="cell-output cell-output-display">
<div id="fig-investment-dag" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-investment-dag-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-investment-dag-output-1.png" width="649" height="220" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-investment-dag-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="analysis" class="level2">
<h2 class="anchored" data-anchor-id="analysis">Analysis</h2>
<section id="expected-value-after-1-flip" class="level3">
<h3 class="anchored" data-anchor-id="expected-value-after-1-flip">1) Expected Value After 1 Flip</h3>
<p>After one flip, the expected value of the account balance is <strong>greater than</strong> $30,000.</p>
<p><strong>Calculation:</strong> - If heads (50% probability): $30,000 √ó 1.5 = $45,000 - If tails (50% probability): $30,000 √ó 0.6 = $18,000 - Expected value = 0.5 √ó $45,000 + 0.5 √ó $18,000 = $31,500</p>
<p>The gain in expected value is <strong>5.0%</strong> of the buy-in ($31,500 - $30,000 = $1,500; $1,500 / $30,000 = 0.05).</p>
<p>However, this simple analysis is <strong>misleading</strong> and does not suggest you should buy-in to the game. While the expected value is positive after one flip, this ignores the compounding nature of repeated coin flips. The asymmetric returns (50% gain vs.&nbsp;40% loss) create a multiplicative process where the expected value grows linearly over time, but the actual outcomes become highly skewed. Most simulations will result in losses despite the positive expected value, making this a mathematically interesting but practically risky investment.</p>
<div id="q1-expected-value-py" class="cell" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>Initial balance: $30,000.00
Heads outcome: $45,000.00
Tails outcome: $18,000.00
Expected value after one flip: $31,500.00
Gain as percentage of buy-in: 5.0%</code></pre>
</div>
</div>
</section>
<section id="single-simulation-over-time-narrative-plot" class="level3">
<h3 class="anchored" data-anchor-id="single-simulation-over-time-narrative-plot">2) Single Simulation Over Time (Narrative + Plot)</h3>
<p>The single simulation below shows a typical path for this investment game. Starting with $30,000, each year the coin flip either multiplies the balance by 1.5 (heads) or 0.6 (tails). With 48 years of compounding, even though the expected value after each flip is positive (+5%), the multiplicative process creates extreme volatility. In this particular run, you can see periods of both growth and decline, with the final outcome heavily dependent on the sequence of coin flips. The mathematical property that makes this investment risky is that losses compound exponentially‚Äîa few consecutive tails can devastate the balance even if the overall expected value remains positive.</p>
<div id="cell-q2-single-sim-py" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">
<div id="q2-single-sim-py" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/q2-single-sim-py-output-1.png" width="950" height="566" class="figure-img"></p>
<figcaption>Single simulation path of account balance over 48 years</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Starting balance: $30,000.00
Ending balance: $37,390.52
Final gain/loss: $7,390.52
Percentage change: 24.6%</code></pre>
</div>
</div>
</section>
<section id="simulations-distribution-of-final-balances" class="level3">
<h3 class="anchored" data-anchor-id="simulations-distribution-of-final-balances">3) 100 Simulations: Distribution of Final Balances</h3>
<p>Running 100 simulations reveals a striking property of this investment game: the distribution of final balances is highly right-skewed with a long tail extending to extremely high values. Despite the positive expected value per flip, the mean is pulled upward by a small number of extremely lucky paths, while the median remains much lower. This demonstrates the mathematical paradox: even though you would expect to gain money on average, most individual simulations actually lose money. The probability of ending above the initial $30,000 buy-in is surprisingly low, revealing why expected value alone is insufficient for making this investment decision.</p>
<div id="cell-q3-dist-100-py" class="cell" data-execution_count="5">
<div class="cell-output cell-output-display">
<div id="q3-dist-100-py" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/q3-dist-100-py-output-1.png" width="951" height="662" class="figure-img"></p>
<figcaption>Distribution of final balances across 100 simulations</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Mean final balance: $303,351.48
Median final balance: $2,392.99
P(final &gt; $30,000): 0.220
P(final ‚â§ $30,000): 0.780</code></pre>
</div>
</div>
</section>
<section id="probability-balance-30000-at-age-75-original-game" class="level3">
<h3 class="anchored" data-anchor-id="probability-balance-30000-at-age-75-original-game">4) Probability Balance &gt; $30,000 at Age 75 (Original Game)</h3>
<p>Using the 100 simulations above, the probability that your final balance exceeds the initial $30,000 buy-in is quite low. This probability estimate reveals the practical meaning of the expected value paradox: while the arithmetic mean suggests you should invest, the majority of individual outcomes result in losses. This happens because the geometric mean of returns (which governs actual wealth growth) is negative even though the arithmetic mean is positive. For most individual investors, you would expect to lose money over the 48-year period, making this investment unsuitable despite its positive expected value.</p>
<div id="q4-prob-original-py" class="cell" data-execution_count="6">
<div class="cell-output cell-output-stdout">
<pre><code>Estimated P(final &gt; $30,000): 0.220</code></pre>
</div>
</div>
</section>
<section id="modified-strategy-bet-exactly-50-each-round" class="level3">
<h3 class="anchored" data-anchor-id="modified-strategy-bet-exactly-50-each-round">5) Modified Strategy (Bet Exactly 50% Each Round)</h3>
<p>Nate Prince: ‚Äù How about this‚Ä¶ Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. I‚Äôll compare this to the original game. Which is riskier? Which has better upside?‚Äù Professor Adam: ‚ÄúI‚Äôll let you decide.‚Äù</p>
<p>The modified strategy dramatically changes the risk profile. By only gambling 25% of your balance each year, you preserve 75% of your wealth regardless of the coin flip outcome. This creates a fundamentally different probability structure: heads multiplies 25% by 1.5 and adds it back, while tails multiplies 25% by 0.6. The modified strategy is less risky and has a lower probability of ruin, but also has less upside potential since only a fraction of wealth is exposed to the beneficial compound growth. The distribution of outcomes is more centered and predictable compared to the original‚Äôs extreme skewness.</p>
<div id="cell-q5-modified-50pct-py" class="cell" data-execution_count="7">
<div class="cell-output cell-output-display">
<div id="q5-modified-50pct-py" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/q5-modified-50pct-py-output-1.png" width="1333" height="564" class="figure-img"></p>
<figcaption>Comparison of original vs modified strategy distributions</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>============================================================
COMPARISON: Original vs Modified Strategy
============================================================

Original Strategy:
  Mean: $303,351.48
  Median: $2,392.99
  P(final &gt; $30,000): 0.220

Modified Strategy (25% bet):
  Mean: $56,229.23
  Median: $40,420.53
  P(final &gt; $30,000): 0.630

Which is riskier? The ORIGINAL strategy (higher variance, more extreme outcomes)
Which has better upside? The ORIGINAL strategy (higher mean, more high-value outliers)
Which is safer? The MODIFIED strategy (higher P(&gt;30k), less variance)</code></pre>
</div>
</div>
</section>
<section id="briefly-explain-your-findings-from-the-previous-step-in-light-of-a-concept-known-as-the-kelly-criterion" class="level3">
<h3 class="anchored" data-anchor-id="briefly-explain-your-findings-from-the-previous-step-in-light-of-a-concept-known-as-the-kelly-criterion">6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the ‚ÄúKelly Criterion‚Äù</h3>
<p>Nate Prince: ‚ÄúI‚Äôve heard of the Kelly Criterion, but I‚Äôm not sure how it applies to this game.‚Äù Professor Adam: ‚ÄúLet‚Äôs take a look.‚Äù</p>
<p>The Kelly Criterion is a mathematical formula that determines the optimal fraction of capital to bet on repeated favorable bets to maximize long-term growth rate. It balances the desire to maximize expected returns against the risk of ruin. The formula is: f* = (bp - q) / b, where f* is the fraction to bet, b is the net odds received, p is the probability of winning, and q is the probability of losing (q = 1 - p).</p>
<p>For the coin flip game, let‚Äôs analyze: p = 0.5 (probability of heads), b = 0.5 (net gain of 50%), and q = 0.4 (net loss of 40%). This gives: f* = (0.5 √ó 0.5 - 0.4) / 0.5 = (0.25 - 0.4) / 0.5 = -0.3. Since the result is negative, the Kelly Criterion recommends not betting at all‚Äîthe bet is unfavorable despite having a positive expected value.</p>
<p>This explains the paradox: the game has positive expected value but is a losing proposition in the long run. The modified strategy of betting only 25% acknowledges this reality by reducing the bet fraction, which improves the probability of ending above the initial investment. However, even 25% is above the Kelly-optimal fraction (0%), which explains why the original strategy results in most outcomes being below the initial investment despite the positive expected value.</p>
</section>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>The investment game is a classic example of the importance of considering the long-term implications of short-term gains. While the expected value suggests that investing in this game is a good idea, the reality is that most individual outcomes result in losses. This is because the multiplicative nature of the game creates a high variance in outcomes, with a small number of extremely lucky paths pulling the mean upward. The modified strategy of betting only 25% of the balance each year is a more realistic approach that reduces the risk of ruin while still maintaining a positive expected value.</p>
<p>In short, professor Adam‚Äôs proposition is a losing proposition in the long run. Tried to set us up for financial failure ü§¶ And Nate Prince is still trying to figure out how to get his money back.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>